"""
Ear-insertable Sensor Simulator

This module simulates the data generated by the ear-insertable biosensor with
frequency-scanning impedance technology. It generates synthetic data that mimics:
- EEG signals
- Body temperature
- Blood flow measurements
- Electrochemical impedance readings

The simulator can generate normal readings as well as patterns associated with 
various mental health conditions.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import random
import json

class EarSensorSimulator:
    """
    Simulator for the ear-insertable sensor with frequency-scanning impedance technology.
    
    Capable of generating synthetic biosensor data for various mental health states.
    """
    
    def __init__(self, user_id, mental_state="normal"):
        """
        Initialize the sensor simulator.
        
        Args:
            user_id (str): Unique identifier for the user
            mental_state (str): Mental state to simulate. Options:
                - "normal": Normal mental health state
                - "depression": Depressive state
                - "anxiety": Anxiety state
                - "stress": Stress state
                - "bipolar_manic": Bipolar disorder - manic phase
                - "bipolar_depressive": Bipolar disorder - depressive phase
        """
        self.user_id = user_id
        self.mental_state = mental_state
        self.sampling_rate = 256  # Hz
        self.timestamp = datetime.now()
        
        # Parameters for each mental state
        self.state_params = {
            "normal": {
                "eeg_amplitude": 1.0,
                "eeg_alpha_power": 0.7,
                "eeg_beta_power": 0.3,
                "eeg_theta_power": 0.2,
                "eeg_delta_power": 0.1,
                "temp_base": 37.0,
                "temp_variance": 0.1,
                "blood_flow_base": 100,
                "blood_flow_variance": 5,
                "impedance_frequencies": np.linspace(10, 100000, 50),  # Hz
                "impedance_scaling": 1.0
            },
            "depression": {
                "eeg_amplitude": 0.8,
                "eeg_alpha_power": 0.4,
                "eeg_beta_power": 0.2,
                "eeg_theta_power": 0.3,
                "eeg_delta_power": 0.5,
                "temp_base": 36.8,
                "temp_variance": 0.05,
                "blood_flow_base": 90,
                "blood_flow_variance": 3,
                "impedance_frequencies": np.linspace(10, 100000, 50),  # Hz
                "impedance_scaling": 1.2
            },
            "anxiety": {
                "eeg_amplitude": 1.3,
                "eeg_alpha_power": 0.3,
                "eeg_beta_power": 0.8,
                "eeg_theta_power": 0.2,
                "eeg_delta_power": 0.1,
                "temp_base": 37.2,
                "temp_variance": 0.2,
                "blood_flow_base": 120,
                "blood_flow_variance": 15,
                "impedance_frequencies": np.linspace(10, 100000, 50),  # Hz
                "impedance_scaling": 0.9
            },
            "stress": {
                "eeg_amplitude": 1.2,
                "eeg_alpha_power": 0.3,
                "eeg_beta_power": 0.7,
                "eeg_theta_power": 0.2,
                "eeg_delta_power": 0.1,
                "temp_base": 37.3,
                "temp_variance": 0.15,
                "blood_flow_base": 110,
                "blood_flow_variance": 10,
                "impedance_frequencies": np.linspace(10, 100000, 50),  # Hz
                "impedance_scaling": 0.85
            },
            "bipolar_manic": {
                "eeg_amplitude": 1.5,
                "eeg_alpha_power": 0.2,
                "eeg_beta_power": 0.9,
                "eeg_theta_power": 0.1,
                "eeg_delta_power": 0.05,
                "temp_base": 37.4,
                "temp_variance": 0.25,
                "blood_flow_base": 130,
                "blood_flow_variance": 20,
                "impedance_frequencies": np.linspace(10, 100000, 50),  # Hz
                "impedance_scaling": 0.7
            },
            "bipolar_depressive": {
                "eeg_amplitude": 0.7,
                "eeg_alpha_power": 0.4,
                "eeg_beta_power": 0.2,
                "eeg_theta_power": 0.3,
                "eeg_delta_power": 0.6,
                "temp_base": 36.7,
                "temp_variance": 0.05,
                "blood_flow_base": 85,
                "blood_flow_variance": 3,
                "impedance_frequencies": np.linspace(10, 100000, 50),  # Hz
                "impedance_scaling": 1.3
            }
        }
        
        # Set up parameters for the selected mental state
        self.params = self.state_params.get(mental_state, self.state_params["normal"])
    
    def generate_eeg_data(self, duration_seconds=1):
        """
        Generate synthetic EEG data for the specified duration.
        
        Args:
            duration_seconds (float): Duration in seconds for which to generate data
            
        Returns:
            dict: Dictionary containing EEG channel data
        """
        num_samples = int(duration_seconds * self.sampling_rate)
        t = np.arange(num_samples) / self.sampling_rate
        
        # Generate frequency components
        alpha_wave = self.params["eeg_alpha_power"] * np.sin(2 * np.pi * 10 * t)  # Alpha: 8-12 Hz
        beta_wave = self.params["eeg_beta_power"] * np.sin(2 * np.pi * 20 * t)    # Beta: 12-30 Hz
        theta_wave = self.params["eeg_theta_power"] * np.sin(2 * np.pi * 5 * t)    # Theta: 4-8 Hz
        delta_wave = self.params["eeg_delta_power"] * np.sin(2 * np.pi * 2 * t)    # Delta: 0.5-4 Hz
        
        # Combine waves with noise
        noise = 0.1 * np.random.normal(0, 1, num_samples)
        base_signal = alpha_wave + beta_wave + theta_wave + delta_wave + noise
        
        # Generate 16 channels with slight variations
        channels = {}
        for i in range(16):
            channel_noise = 0.05 * np.random.normal(0, 1, num_samples)
            channels[f'channel_{i+1}'] = self.params["eeg_amplitude"] * (base_signal + channel_noise)
        
        return {
            'timestamp': self.timestamp.strftime('%Y-%m-%d %H:%M:%S.%f'),
            'sampling_rate': self.sampling_rate,
            'channels': channels
        }
    
    def generate_temperature_data(self):
        """
        Generate synthetic body temperature data.
        
        Returns:
            dict: Dictionary containing temperature data
        """
        base_temp = self.params["temp_base"]
        variance = self.params["temp_variance"]
        
        # Add random fluctuation around base temperature
        temp = base_temp + random.uniform(-variance, variance)
        
        return {
            'timestamp': self.timestamp.strftime('%Y-%m-%d %H:%M:%S.%f'),
            'temperature_celsius': round(temp, 2)
        }
    
    def generate_blood_flow_data(self):
        """
        Generate synthetic blood flow measurement data.
        
        Returns:
            dict: Dictionary containing blood flow data
        """
        base_flow = self.params["blood_flow_base"]
        variance = self.params["blood_flow_variance"]
        
        # Blood flow in arbitrary units with random fluctuation
        flow = base_flow + random.uniform(-variance, variance)
        # Oxygen saturation percentage
        oxygen = 95 + random.uniform(-2, 3)
        
        return {
            'timestamp': self.timestamp.strftime('%Y-%m-%d %H:%M:%S.%f'),
            'blood_flow': round(flow, 2),
            'oxygen_saturation_percent': round(oxygen, 1)
        }
    
    def generate_impedance_data(self):
        """
        Generate synthetic impedance spectroscopy data.
        
        Returns:
            dict: Dictionary containing impedance data at different frequencies
        """
        frequencies = self.params["impedance_frequencies"]
        
        # Model impedance as a function of frequency with some randomness
        # Use Cole-Cole model approximation for biological tissue
        R0 = 500  # Low frequency resistance
        Rinf = 100  # High frequency resistance
        
        # Scaling factor specific to mental state
        scaling = self.params["impedance_scaling"]
        
        # Calculate impedance magnitude using simplified model
        alpha = 0.8  # Cole-Cole parameter
        tau = 1e-3   # Time constant
        impedance = []
        
        for f in frequencies:
            # Add specific signature based on mental state
            w = 2 * np.pi * f
            denom = 1 + (1j * w * tau) ** alpha
            Z = Rinf + (R0 - Rinf) / denom
            
            # Magnitude with randomness and mental state scaling
            magnitude = abs(Z) * scaling * (1 + 0.05 * np.random.normal())
            phase = np.angle(Z) + 0.02 * np.random.normal()
            
            impedance.append({
                'frequency_hz': float(f),
                'magnitude_ohm': float(magnitude),
                'phase_rad': float(phase)
            })
        
        return {
            'timestamp': self.timestamp.strftime('%Y-%m-%d %H:%M:%S.%f'),
            'impedance_measurements': impedance
        }
    
    def generate_sensor_data_packet(self, duration_seconds=1):
        """
        Generate a complete data packet with all sensor measurements.
        
        Args:
            duration_seconds (float): Duration in seconds for EEG data
            
        Returns:
            dict: Complete sensor data packet
        """
        self.timestamp = datetime.now()
        
        data_packet = {
            'user_id': self.user_id,
            'device_id': f'ear_sensor_{self.user_id}',
            'timestamp': self.timestamp.strftime('%Y-%m-%d %H:%M:%S.%f'),
            'eeg_data': self.generate_eeg_data(duration_seconds),
            'temperature_data': self.generate_temperature_data(),
            'blood_flow_data': self.generate_blood_flow_data(),
            'impedance_data': self.generate_impedance_data()
        }
        
        return data_packet
    
    def simulate_continuous_data(self, duration_minutes=5, interval_seconds=1):
        """
        Simulate continuous data stream for a specified duration.
        
        Args:
            duration_minutes (float): Total duration in minutes
            interval_seconds (float): Interval between data packets in seconds
            
        Returns:
            list: List of data packets
        """
        data_packets = []
        total_seconds = duration_minutes * 60
        num_packets = int(total_seconds / interval_seconds)
        
        start_time = datetime.now()
        
        for i in range(num_packets):
            # Update timestamp
            self.timestamp = start_time + timedelta(seconds=i * interval_seconds)
            data_packets.append(self.generate_sensor_data_packet(interval_seconds))
        
        return data_packets
    
    def save_simulated_data(self, data_packets, filename):
        """
        Save simulated data to a JSON file.
        
        Args:
            data_packets (list): List of data packets
            filename (str): Output filename
        """
        with open(filename, 'w') as f:
            json.dump(data_packets, f, indent=2)
        
        print(f"Saved {len(data_packets)} data packets to {filename}")


if __name__ == "__main__":
    # Example usage
    print("Ear Sensor Simulator Demo")
    
    # Create simulators for different mental states
    simulators = {}
    mental_states = ["normal", "depression", "anxiety", "stress", 
                    "bipolar_manic", "bipolar_depressive"]
    
    for state in mental_states:
        simulators[state] = EarSensorSimulator(user_id=f"user_{state}", mental_state=state)
    
    # Generate sample data for each state
    for state, simulator in simulators.items():
        print(f"\nGenerating sample data for {state} state...")
        data = simulator.generate_sensor_data_packet()
        
        # Get impedance data for visualization
        impedance_data = data["impedance_data"]["impedance_measurements"]
        frequencies = [item["frequency_hz"] for item in impedance_data]
        magnitudes = [item["magnitude_ohm"] for item in impedance_data]
        
        # Plot impedance spectrum
        plt.figure(figsize=(10, 6))
        plt.loglog(frequencies, magnitudes)
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Impedance (Ohm)')
        plt.title(f'Impedance Spectrum - {state.capitalize()} State')
        plt.grid(True, which="both", ls="--")
        plt.savefig(f"impedance_{state}.png")
        
        # Save sample data
        simulator.save_simulated_data([data], f"sample_data_{state}.json")
    
    print("\nSimulation complete. Sample data and plots generated.")
